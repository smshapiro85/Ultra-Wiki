---
phase: 07-ask-ai-notifications
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/notifications/slack.ts
  - src/lib/notifications/email.ts
  - src/lib/notifications/templates.ts
  - src/lib/notifications/service.ts
  - src/app/api/admin/settings/test-notification/route.ts
  - src/app/(admin)/admin/settings/api-keys-settings.tsx
  - src/app/api/articles/[id]/comments/route.ts
  - src/lib/ai/pipeline.ts
  - src/lib/merge/conflict.ts
autonomous: true
user_setup:
  - service: slack
    why: "Slack DM notifications to users"
    env_vars: []
    dashboard_config:
      - task: "Create a Slack App with Bot Token (chat:write scope)"
        location: "https://api.slack.com/apps -> Create New App -> OAuth & Permissions -> Add chat:write scope -> Install to Workspace -> Copy Bot User OAuth Token"
  - service: sendgrid
    why: "Email notifications to users"
    env_vars: []
    dashboard_config:
      - task: "Create SendGrid account and API key"
        location: "https://app.sendgrid.com -> Settings -> API Keys -> Create API Key (Mail Send permission) -> Verify sender email"

must_haves:
  truths:
    - "User receives Slack DM when mentioned in a comment (if Slack enabled and slackUserId set)"
    - "User receives email when mentioned in a comment (if email enabled)"
    - "User receives notification when someone comments on an article they edited or commented on"
    - "User receives notification when AI sync updates an article they edited"
    - "User receives notification when AI flags a conflict on an article they edited"
    - "Admin can test Slack bot token and SendGrid API key from settings page"
    - "Notification delivery never blocks the primary action (fire-and-forget)"
  artifacts:
    - path: "src/lib/notifications/slack.ts"
      provides: "sendSlackDM function using Slack chat.postMessage REST API"
      exports: ["sendSlackDM"]
    - path: "src/lib/notifications/email.ts"
      provides: "sendEmail function using SendGrid v3/mail/send REST API"
      exports: ["sendEmail"]
    - path: "src/lib/notifications/templates.ts"
      provides: "Notification message templates for all event types"
      exports: ["templates"]
    - path: "src/lib/notifications/service.ts"
      provides: "Notification dispatcher with preference checking"
      exports: ["notifyMention", "notifyNewComment", "notifyAiSyncUpdate", "notifyAiConflict"]
    - path: "src/app/api/admin/settings/test-notification/route.ts"
      provides: "POST endpoint for testing Slack/SendGrid configuration"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/articles/[id]/comments/route.ts"
      to: "src/lib/notifications/service.ts"
      via: "fire-and-forget notifyMention + notifyNewComment after comment insert"
      pattern: "notifyMention|notifyNewComment"
    - from: "src/lib/ai/pipeline.ts"
      to: "src/lib/notifications/service.ts"
      via: "fire-and-forget notifyAiSyncUpdate after article update"
      pattern: "notifyAiSyncUpdate"
    - from: "src/lib/merge/conflict.ts"
      to: "src/lib/notifications/service.ts"
      via: "fire-and-forget notifyAiConflict when needsReview is set"
      pattern: "notifyAiConflict"
---

<objective>
Build the notification service (Slack DM, SendGrid email) with preference-based routing and wire all four notification trigger points.

Purpose: Users receive timely notifications about activity that matters to them -- mentions, comments, AI updates, and conflicts -- via their preferred channels (Slack and/or email).
Output: Notification library (Slack, email, templates, service), test notification endpoint with admin UI buttons, notification triggers wired into comments, pipeline, and conflict resolution.
</objective>

<execution_context>
@/Users/michael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ask-ai-notifications/07-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/settings/constants.ts
@src/app/api/articles/[id]/comments/route.ts
@src/lib/ai/pipeline.ts
@src/lib/merge/conflict.ts
@src/app/api/admin/settings/test-connection/route.ts
@src/app/(admin)/admin/settings/api-keys-settings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification library (Slack, email, templates, service dispatcher)</name>
  <files>
    src/lib/notifications/slack.ts
    src/lib/notifications/email.ts
    src/lib/notifications/templates.ts
    src/lib/notifications/service.ts
  </files>
  <action>
**Step 1: Create `src/lib/notifications/slack.ts`**
Single function `sendSlackDM(slackUserId: string, text: string): Promise<void>`:
- Load bot token from `getSetting(SETTING_KEYS.slack_bot_token)`
- If no token, throw Error('Slack bot token not configured')
- `fetch('https://slack.com/api/chat.postMessage', { method: 'POST', headers: { Authorization: Bearer {token}, Content-Type: application/json }, body: JSON.stringify({ channel: slackUserId, text }) })`
- Parse response JSON, check `data.ok` -- if false, throw `Error('Slack API error: ' + data.error)`
- Follow exact pattern from research code example

**Step 2: Create `src/lib/notifications/email.ts`**
Single function `sendEmail(to: string, subject: string, htmlContent: string): Promise<void>`:
- Load API key and from email from settings in parallel: `getSetting(SETTING_KEYS.sendgrid_api_key)` and `getSetting(SETTING_KEYS.sendgrid_from_email)`
- If no API key, throw Error('SendGrid API key not configured')
- If no from email, throw Error('SendGrid from email not configured')
- `fetch('https://api.sendgrid.com/v3/mail/send', { method: 'POST', headers: { Authorization: Bearer {apiKey}, Content-Type: application/json }, body: JSON.stringify({ personalizations: [{ to: [{ email: to }] }], from: { email: fromEmail }, subject, content: [{ type: 'text/html', value: htmlContent }] }) })`
- If `!response.ok`, read error body and throw
- Follow exact pattern from research code example

**Step 3: Create `src/lib/notifications/templates.ts`**
Export a `templates` object with methods for each notification type. Each returns `{ slack: string, subject: string, html: string }`:

```typescript
export const templates = {
  mention: ({ mentionerName, articleTitle, articleSlug, commentPreview }: {
    mentionerName: string; articleTitle: string; articleSlug: string; commentPreview: string;
  }) => ({
    slack: `*${mentionerName}* mentioned you in a comment on "${articleTitle}":\n>${commentPreview}`,
    subject: `${mentionerName} mentioned you on "${articleTitle}"`,
    html: `<p><strong>${esc(mentionerName)}</strong> mentioned you in a comment on <a href="${baseUrl()}/wiki/${articleSlug}">${esc(articleTitle)}</a>:</p><blockquote>${esc(commentPreview)}</blockquote>`,
  }),

  newComment: ({ commenterName, articleTitle, articleSlug }: {
    commenterName: string; articleTitle: string; articleSlug: string;
  }) => ({
    slack: `*${commenterName}* commented on "${articleTitle}"`,
    subject: `New comment on "${articleTitle}"`,
    html: `<p><strong>${esc(commenterName)}</strong> posted a new comment on <a href="${baseUrl()}/wiki/${articleSlug}">${esc(articleTitle)}</a>.</p>`,
  }),

  aiSyncUpdate: ({ articleTitle, articleSlug }: {
    articleTitle: string; articleSlug: string;
  }) => ({
    slack: `AI has updated the article "${articleTitle}" based on code changes`,
    subject: `AI updated "${articleTitle}"`,
    html: `<p>The AI pipeline has updated <a href="${baseUrl()}/wiki/${articleSlug}">${esc(articleTitle)}</a> based on recent code changes. Your previous edits have been preserved.</p>`,
  }),

  aiConflict: ({ articleTitle, articleSlug }: {
    articleTitle: string; articleSlug: string;
  }) => ({
    slack: `:warning: AI detected a merge conflict on "${articleTitle}" that needs review`,
    subject: `Merge conflict on "${articleTitle}" needs review`,
    html: `<p>The AI pipeline found a merge conflict while updating <a href="${baseUrl()}/wiki/${articleSlug}">${esc(articleTitle)}</a>. Your edits were preserved, but the article needs review.</p>`,
  }),
};
```

Helper: `function esc(s: string): string` -- escape HTML entities (&, <, >, ", ').
Helper: `function baseUrl(): string` -- return `process.env.NEXTAUTH_URL || 'http://localhost:3000'` (strip trailing slash).

**Step 4: Create `src/lib/notifications/service.ts`**
Import `sendSlackDM`, `sendEmail`, `templates`, `getDb`, `users`, `comments`, `articles` tables.

Four exported functions, all fire-and-forget safe (wrap everything in try/catch, log errors, never throw):

1. `notifyMention(mentionedUserId: string, mentionerName: string, articleTitle: string, articleSlug: string, commentPreview: string): Promise<void>`
   - Query user's notification preferences: `notifyOnMention`, `notifySlackEnabled`, `slackUserId`, `notifyEmailEnabled`, `email`
   - If `!notifyOnMention`, return early
   - Build message via `templates.mention(...)`
   - Fire Slack DM if slack enabled + slackUserId set
   - Fire email if email enabled + email set
   - Use `Promise.allSettled` for parallel delivery

2. `notifyNewComment(articleId: string, commentAuthorId: string, commenterName: string, articleTitle: string, articleSlug: string): Promise<void>`
   - Find users to notify: query `comments` table for distinct `userId` where `articleId` matches, UNION with article's `lastHumanEditorId`. Exclude the `commentAuthorId`.
   - For each user, check `notifyOnActivity` preference
   - Build message via `templates.newComment(...)`
   - Fire notifications to each user via their preferred channels
   - Use `Promise.allSettled` for all deliveries

3. `notifyAiSyncUpdate(articleId: string, articleTitle: string, articleSlug: string): Promise<void>`
   - Find article's `lastHumanEditorId` from articles table
   - If no human editor, return (no one to notify)
   - Query that user's preferences
   - If `notifyOnActivity` is true, send via preferred channels
   - Build message via `templates.aiSyncUpdate(...)`

4. `notifyAiConflict(articleId: string, articleTitle: string, articleSlug: string): Promise<void>`
   - Same as aiSyncUpdate but uses `templates.aiConflict(...)` message
   - Notify the `lastHumanEditorId`

All four functions follow the pattern: try { ... } catch (error) { console.error('[notifications] ...', error); } -- never throw.
  </action>
  <verify>
- `npm run build` succeeds
- All four files exist with correct exports
- No runtime imports of external SDKs (only fetch)
  </verify>
  <done>
- sendSlackDM sends Slack DMs via REST API
- sendEmail sends emails via SendGrid REST API
- Templates produce Slack text, email subject, and HTML for all four event types
- Service dispatcher checks user preferences before sending, never blocks, never throws
  </done>
</task>

<task type="auto">
  <name>Task 2: Test notification endpoint, admin UI test buttons, and wire all notification triggers</name>
  <files>
    src/app/api/admin/settings/test-notification/route.ts
    src/app/(admin)/admin/settings/api-keys-settings.tsx
    src/app/api/articles/[id]/comments/route.ts
    src/lib/ai/pipeline.ts
    src/lib/merge/conflict.ts
  </files>
  <action>
**Step 1: Create `src/app/api/admin/settings/test-notification/route.ts`**
POST endpoint. Admin-only auth check. Body: `{ type: 'slack' | 'sendgrid', value: string }`.

For `type === 'slack'`:
- `value` is the bot token to test
- First call `fetch('https://slack.com/api/auth.test', { headers: { Authorization: Bearer {value} } })` to validate the token
- Parse response. If `data.ok`, return `{ success: true, message: 'Slack bot authenticated as ' + (data.bot_id || data.user) }`
- If not ok, return `{ success: false, error: 'Slack auth failed: ' + data.error }`

For `type === 'sendgrid'`:
- `value` is the API key to test
- Load the from email from the request body as well: `{ type: 'sendgrid', value: string, fromEmail: string, testEmail: string }`
- Send a test email to `testEmail` with subject "CodeWiki Test Notification" and body "<p>This is a test notification from CodeWiki. If you received this, SendGrid is configured correctly.</p>"
- Use raw fetch to SendGrid API (same pattern as email.ts but with the provided key/from directly, not from settings)
- If response.ok (202), return `{ success: true, message: 'Test email sent to ' + testEmail }`
- If not ok, parse error and return `{ success: false, error: '...' }`

**Step 2: Update `src/app/(admin)/admin/settings/api-keys-settings.tsx`**
Add test buttons for Slack and SendGrid, following the existing `TestConnectionButton` pattern:

For **Slack** card: Add a `TestNotificationButton` below the Slack Bot Token input. It reads the current input value, POSTs to `/api/admin/settings/test-notification` with `{ type: 'slack', value: tokenValue }`. Shows success/error result. Help text below: "Required Slack bot scope: `chat:write`. The bot token starts with `xoxb-`."

For **SendGrid** card: Add a `TestNotificationButton` below the SendGrid fields. It needs the API key input value, the from email input value, and an inline text input for "Test email recipient" (default to empty, admin enters their email). POSTs to `/api/admin/settings/test-notification` with `{ type: 'sendgrid', value: apiKeyValue, fromEmail: fromEmailValue, testEmail: recipientValue }`. Shows success/error. Help text: "Sender email must be verified in SendGrid."

Use refs for the Slack bot token input and SendGrid inputs (add `slackTokenRef`, `sendgridKeyRef`, `sendgridFromRef` alongside existing refs).

**Step 3: Update `src/app/api/articles/[id]/comments/route.ts`**
In the POST handler, after the existing mention extraction and insert, add notification triggers:

```typescript
// --- Notification triggers (fire-and-forget) ---
import { notifyMention, notifyNewComment } from '@/lib/notifications/service';

// After mention records inserted:
if (mentionedUserIds.size > 0) {
  // Get article info for notification context
  const [articleInfo] = await db.select({ title: articles.title, slug: articles.slug }).from(articles).where(eq(articles.id, articleId)).limit(1);
  const commenterName = session.user.name || 'Someone';
  const commentPreview = body.contentMarkdown.replace(/@\[[^\]]+\]\([^)]+\)/g, (m) => {
    const display = m.match(/@\[([^\]]+)\]/)?.[1] || '';
    return '@' + display;
  }).slice(0, 200);

  for (const userId of mentionedUserIds) {
    notifyMention(userId, commenterName, articleInfo.title, articleInfo.slug, commentPreview)
      .catch(err => console.error('[notify] mention failed:', err));
  }
}

// Notify users who have commented on or edited this article (NOTF-04)
{
  const [articleInfo] = await db.select({ title: articles.title, slug: articles.slug }).from(articles).where(eq(articles.id, articleId)).limit(1);
  const commenterName = session.user.name || 'Someone';
  notifyNewComment(articleId, session.user.id, commenterName, articleInfo.title, articleInfo.slug)
    .catch(err => console.error('[notify] new comment failed:', err));
}
```

Note: The `articles` import and `articleInfo` query can be combined (avoid duplicate query). Import `articles` from schema at the top.

**Step 4: Update `src/lib/ai/pipeline.ts`**
After the pipeline updates an article that has human edits (i.e., `article.hasHumanEdits` is true and the update succeeded), fire `notifyAiSyncUpdate`:

Find the section where articles are updated (look for the `hasHumanEdits` check and the article update query). After the update:
```typescript
// Fire-and-forget notification for AI sync update (NOTF-05)
import { notifyAiSyncUpdate } from '@/lib/notifications/service';
// (use dynamic import to match pipeline pattern)
const { notifyAiSyncUpdate } = await import('@/lib/notifications/service');
notifyAiSyncUpdate(article.id, article.title, article.slug)
  .catch(err => console.error('[notify] ai sync update failed:', err));
```

Use dynamic import matching the pipeline's existing pattern for avoiding build-time issues.

**Step 5: Update `src/lib/merge/conflict.ts`**
After `resolveConflict` sets `needsReview = true` on an article (conflict case), fire `notifyAiConflict`:

In the section where `needsReview: true` is set on the article:
```typescript
// Fire-and-forget notification for AI conflict (NOTF-06)
const { notifyAiConflict } = await import('@/lib/notifications/service');
notifyAiConflict(params.articleId, /* need title and slug */)
  .catch(err => console.error('[notify] ai conflict failed:', err));
```

The `resolveConflict` function receives `articleId` but may not have `title`/`slug`. Query the article to get them:
```typescript
const [articleInfo] = await db.select({ title: articles.title, slug: articles.slug }).from(articles).where(eq(articles.id, params.articleId)).limit(1);
if (articleInfo) {
  const { notifyAiConflict } = await import('@/lib/notifications/service');
  notifyAiConflict(params.articleId, articleInfo.title, articleInfo.slug)
    .catch(err => console.error('[notify] ai conflict failed:', err));
}
```
  </action>
  <verify>
- `npm run build` succeeds
- Admin settings page shows test buttons for Slack and SendGrid
- Clicking "Test" for Slack with a valid bot token shows success message
- Clicking "Test" for SendGrid with valid credentials sends a test email
- Creating a comment with @mention triggers notification (check console for fire-and-forget log if no Slack/SendGrid configured)
- Pipeline run with human-edited article triggers sync update notification
  </verify>
  <done>
- Admin can test Slack bot token from settings page (NOTF-01)
- Admin can test SendGrid API key from settings page (NOTF-02)
- @mention in comment triggers notification (NOTF-03)
- New comment on article notifies interested users (NOTF-04)
- AI sync update notifies article editors (NOTF-05)
- AI conflict flag notifies article editors (NOTF-06)
- All notifications are fire-and-forget, never blocking primary actions
  </done>
</task>

</tasks>

<verification>
1. Admin settings page: Slack card has "Test" button -- click with valid bot token shows "Slack bot authenticated as ..." (NOTF-01)
2. Admin settings page: SendGrid card has "Test" button with recipient email input -- sends test email on click (NOTF-02)
3. Post a comment with @mention -- mentioned user receives Slack DM and/or email based on their preferences (NOTF-03)
4. Post a comment on an article -- users who previously commented or edited receive notification (NOTF-04)
5. Run AI sync on article with human edits -- `lastHumanEditorId` user receives notification (NOTF-05)
6. AI merge produces conflict -- `lastHumanEditorId` user receives notification about conflict (NOTF-06)
7. Primary actions (comment posting, sync, merge) complete without waiting for notification delivery
</verification>

<success_criteria>
- Slack DM notifications work via bot token (NOTF-01)
- Email notifications work via SendGrid (NOTF-02)
- @mention triggers notification to mentioned user (NOTF-03)
- New comment triggers notification to article stakeholders (NOTF-04)
- AI sync update triggers notification to human editors (NOTF-05)
- AI conflict triggers notification to human editors (NOTF-06)
- Admin can test both notification channels from settings (NOTF-01, NOTF-02)
- Notifications never block primary actions
</success_criteria>

<output>
After completion, create `.planning/phases/07-ask-ai-notifications/07-03-SUMMARY.md`
</output>
