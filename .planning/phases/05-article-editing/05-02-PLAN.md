---
phase: 05-article-editing
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/images/compress.ts
  - src/lib/images/storage.ts
  - src/app/api/articles/[id]/images/route.ts
  - src/app/api/images/[articleId]/[filename]/route.ts
  - src/components/editor/article-editor.tsx
  - src/app/(wiki)/wiki/[articleSlug]/edit/page.tsx
autonomous: true
must_haves:
  truths:
    - "User can paste or drag-drop an image in the editor and it appears inline"
    - "Uploaded images are compressed (max 1200x1200, JPEG quality 80, EXIF stripped)"
    - "Images are stored on local filesystem at /data/images/{articleId}/"
    - "Images are served via API route at /api/images/{articleId}/{filename}"
    - "Image metadata is recorded in the article_images table"
  artifacts:
    - path: "src/lib/images/compress.ts"
      provides: "sharp image compression pipeline"
      min_lines: 15
    - path: "src/lib/images/storage.ts"
      provides: "Filesystem read/write for image storage"
      min_lines: 15
    - path: "src/app/api/articles/[id]/images/route.ts"
      provides: "POST endpoint for image upload"
      exports: ["POST"]
    - path: "src/app/api/images/[articleId]/[filename]/route.ts"
      provides: "GET endpoint for serving images"
      exports: ["GET"]
  key_links:
    - from: "src/components/editor/article-editor.tsx"
      to: "/api/articles/[id]/images"
      via: "uploadFile handler passed to useCreateBlockNote"
      pattern: "uploadFile.*fetch.*images"
    - from: "src/app/api/articles/[id]/images/route.ts"
      to: "src/lib/images/compress.ts"
      via: "compressImage call"
      pattern: "compressImage"
    - from: "src/app/api/articles/[id]/images/route.ts"
      to: "src/lib/images/storage.ts"
      via: "saveImage call"
      pattern: "saveImage"
---

<objective>
Add image upload/paste support to the editor with server-side compression via sharp and filesystem storage.

Purpose: Users need to include images in articles -- pasting screenshots or uploading files. Images must be compressed for performance and stored on the local filesystem as specified.

Output: Image compression library, storage utilities, upload API, serving API, editor uploadFile integration.
</objective>

<execution_context>
@/Users/michael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-article-editing/05-RESEARCH.md
@.planning/phases/05-article-editing/05-01-SUMMARY.md
@src/lib/db/schema.ts
@src/components/editor/article-editor.tsx
@src/app/(wiki)/wiki/[articleSlug]/edit/page.tsx
@package.json
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install sharp and create image compression + storage utilities</name>
  <files>
    package.json
    src/lib/images/compress.ts
    src/lib/images/storage.ts
  </files>
  <action>
    1. Install sharp: `npm install sharp`

    2. Create src/lib/images/compress.ts:
       - Export async function compressImage(inputBuffer: Buffer): Promise<{ data: Buffer; width: number; height: number; sizeBytes: number }>
       - Use sharp(inputBuffer) pipeline:
         * .resize(1200, 1200, { fit: "inside", withoutEnlargement: true }) -- maintain aspect ratio, never upscale
         * .jpeg({ quality: 80, mozjpeg: true }) -- JPEG output at quality 80
         * sharp strips EXIF metadata by default (no explicit call needed)
         * .toBuffer({ resolveWithObject: true }) to get both data and info
       - Return { data: result.data, width: result.info.width, height: result.info.height, sizeBytes: result.info.size }

    3. Create src/lib/images/storage.ts:
       - Import path and fs/promises
       - Define IMAGE_ROOT: process.env.NODE_ENV === "production" ? "/data/images" : "./data/images"
       - Export async function ensureDir(articleId: string): Promise<string>
         * Construct dirPath = path.join(IMAGE_ROOT, articleId)
         * await fs.mkdir(dirPath, { recursive: true })
         * Return dirPath
       - Export async function saveImage(articleId: string, filename: string, data: Buffer): Promise<string>
         * const dirPath = await ensureDir(articleId)
         * const filePath = path.join(dirPath, filename)
         * await fs.writeFile(filePath, data)
         * Return filePath (the full filesystem path for DB storage)
       - Export async function readImage(articleId: string, filename: string): Promise<Buffer | null>
         * const filePath = path.join(IMAGE_ROOT, articleId, filename)
         * try { return await fs.readFile(filePath) } catch { return null }
       - Export function getImageUrl(articleId: string, filename: string): string
         * Return `/api/images/${articleId}/${filename}`
  </action>
  <verify>
    Run `npm ls sharp` -- should show sharp installed.
    Files exist at src/lib/images/compress.ts and src/lib/images/storage.ts.
    Run `npx tsc --noEmit` -- no type errors.
  </verify>
  <done>sharp installed, compression utility handles resize + JPEG + EXIF strip, storage utility handles filesystem read/write with proper paths.</done>
</task>

<task type="auto">
  <name>Task 2: Create upload/serve API routes and wire uploadFile into editor</name>
  <files>
    src/app/api/articles/[id]/images/route.ts
    src/app/api/images/[articleId]/[filename]/route.ts
    src/components/editor/article-editor.tsx
    src/app/(wiki)/wiki/[articleSlug]/edit/page.tsx
  </files>
  <action>
    **A. Create POST /api/articles/[id]/images/route.ts** (image upload):

    - Auth guard: require authenticated session, return 401 if not
    - Parse multipart form data: const formData = await request.formData(); const file = formData.get("file") as File
    - Validate: file exists, file.size < 10MB, file.type starts with "image/"
    - Convert to Buffer: Buffer.from(await file.arrayBuffer())
    - Compress: call compressImage(buffer)
    - Generate unique filename: `${crypto.randomUUID()}.jpg` (always JPEG after compression)
    - Save to filesystem: await saveImage(articleId, filename, compressed.data)
    - Record in article_images table: insert { articleId: id, fileName: filename, filePath, mimeType: "image/jpeg", sizeBytes: compressed.sizeBytes, uploadedBy: session.user.id }
    - Return 200 { url: getImageUrl(id, filename) }

    **B. Create GET /api/images/[articleId]/[filename]/route.ts** (image serving):

    - No auth required (images are accessible to all authenticated wiki users -- the wiki layout already requires auth)
    - Read from filesystem: await readImage(articleId, filename)
    - If null, return 404
    - Return new Response(data, { headers: { "Content-Type": "image/jpeg", "Cache-Control": "public, max-age=31536000, immutable" } })
    - The immutable cache header is safe because filenames are UUIDs -- content never changes for a given filename

    **C. Update src/components/editor/article-editor.tsx**:

    - The uploadFile function should already be accepted as a prop or defined inline. If Plan 01 left it as an optional prop with undefined default, now define the actual implementation:
      ```typescript
      const uploadFile = useCallback(async (file: File): Promise<string> => {
        const formData = new FormData();
        formData.append("file", file);
        const res = await fetch(`/api/articles/${articleId}/images`, {
          method: "POST",
          body: formData,
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({ error: "Upload failed" }));
          throw new Error(err.error || "Upload failed");
        }
        const { url } = await res.json();
        return url;
      }, [articleId]);
      ```
    - Pass uploadFile to useCreateBlockNote({ uploadFile })
    - This enables the built-in BlockNote image block to handle paste and drag-drop automatically

    **D. Update edit page if needed**: Ensure the edit page does NOT pass an uploadFile prop anymore (it should be self-contained in the editor component now).
  </action>
  <verify>
    Run `npm run build` -- should compile without errors.
    Create data/images directory locally if it does not exist: `mkdir -p data/images`.
    The upload route at /api/articles/[id]/images should exist.
    The serve route at /api/images/[articleId]/[filename] should exist.
  </verify>
  <done>
    Images pasted or dropped in the editor are uploaded to the server, compressed via sharp (max 1200x1200, JPEG quality 80, EXIF stripped), stored on filesystem at /data/images/{articleId}/, recorded in article_images table, and served via /api/images/{articleId}/{filename} with immutable cache headers.
  </done>
</task>

</tasks>

<verification>
1. Open editor, paste an image -- image appears inline in editor
2. Save the article -- image URL persists in the BlockNote JSON
3. View the article page -- image renders via /api/images/ URL
4. Check filesystem -- compressed JPEG exists at data/images/{articleId}/{uuid}.jpg
5. Check article_images table -- record exists with correct metadata
6. Verify image is smaller than original (compression working)
</verification>

<success_criteria>
- Images paste and drag-drop work in the BlockNote editor
- Uploaded images are JPEG, max 1200x1200, quality 80, no EXIF
- Images stored at /data/images/{articleId}/ on filesystem
- Images served via GET /api/images/{articleId}/{filename} with cache headers
- article_images records created for each upload
- Build passes, no SSR issues with sharp (server-only code)
</success_criteria>

<output>
After completion, create `.planning/phases/05-article-editing/05-02-SUMMARY.md`
</output>
