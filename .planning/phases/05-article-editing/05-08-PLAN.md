---
phase: 05-article-editing
plan: 08
type: execute
wave: 2
depends_on: ["05-06"]
files_modified:
  - src/lib/db/schema.ts
  - src/app/layout.tsx
  - src/components/common/theme-provider.tsx
  - src/app/(wiki)/profile/page.tsx
  - src/app/(wiki)/profile/actions.ts
  - src/app/(wiki)/profile/profile-form.tsx
  - src/components/editor/article-editor.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can toggle between auto (system), light, and dark mode from their profile page"
    - "Theme preference persists in the users table (survives logout/login)"
    - "Theme applies app-wide via next-themes ThemeProvider in root layout"
    - "BlockNote editor respects the current theme (light/dark)"
    - "The html element has class='dark' when dark mode is active"
  artifacts:
    - path: "src/components/common/theme-provider.tsx"
      provides: "Client-side ThemeProvider wrapper using next-themes"
    - path: "src/app/layout.tsx"
      provides: "Root layout with ThemeProvider wrapping children"
    - path: "src/lib/db/schema.ts"
      provides: "themePreference column on users table"
    - path: "src/app/(wiki)/profile/profile-form.tsx"
      provides: "Theme toggle control in profile form"
  key_links:
    - from: "src/app/layout.tsx"
      to: "src/components/common/theme-provider.tsx"
      via: "ThemeProvider wrapping children"
      pattern: "ThemeProvider"
    - from: "src/app/(wiki)/profile/profile-form.tsx"
      to: "next-themes"
      via: "useTheme hook for theme switching"
      pattern: "useTheme"
    - from: "src/components/editor/article-editor.tsx"
      to: "next-themes"
      via: "useTheme to pass current theme to BlockNoteView"
      pattern: "useTheme"
---

<objective>
Add light/dark mode support using next-themes (already installed). ThemeProvider in root layout, theme toggle in user profile, preference persisted in users table, and BlockNote editor respects current theme.

Purpose: Users can choose their preferred color scheme. The app respects system preferences by default and allows explicit override.
Output: ThemeProvider setup, users.themePreference column, profile form theme control, editor theme integration.
</objective>

<execution_context>
@/Users/michael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/layout.tsx
@src/lib/db/schema.ts
@src/app/(wiki)/profile/page.tsx
@src/app/(wiki)/profile/profile-form.tsx
@src/app/(wiki)/profile/actions.ts
@src/components/editor/article-editor.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add themePreference column, create ThemeProvider, and wire into root layout</name>
  <files>src/lib/db/schema.ts, src/components/common/theme-provider.tsx, src/app/layout.tsx</files>
  <action>
**1. Add themePreference column to users table in src/lib/db/schema.ts:**

Add a `themePreference` text column to the users table (after `notifyOnActivity`):
```ts
themePreference: text("theme_preference").default("system").notNull(),
```

Use a text column with default "system" (not an enum -- three values "system"|"light"|"dark" don't need a Postgres enum). This avoids migration complexity.

After editing, run:
```bash
npx drizzle-kit generate
npx drizzle-kit push
```

**2. Create src/components/common/theme-provider.tsx:**

A client component wrapper for next-themes:
```tsx
"use client";

import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({ children, ...props }: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
```

**3. Update src/app/layout.tsx:**

Wrap children with ThemeProvider. The key configurations:
- `attribute="class"` — applies dark class to html element (required for Tailwind dark mode)
- `defaultTheme="system"` — respects OS preference by default
- `enableSystem` — enables system theme detection
- `disableTransitionOnChange` — prevents flash during theme switch

Update the `<html>` tag to include `suppressHydrationWarning` (required by next-themes to prevent hydration mismatch):

```tsx
import { ThemeProvider } from "@/components/common/theme-provider";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <AuthSessionProvider>
          <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            {children}
            <Toaster />
          </ThemeProvider>
        </AuthSessionProvider>
      </body>
    </html>
  );
}
```

Note: Toaster (sonner) should be inside ThemeProvider so it respects the theme.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Run `npm run build` to verify compilation. Read layout.tsx to confirm ThemeProvider wraps children with correct props. Read schema.ts to confirm themePreference column exists.
  </verify>
  <done>
ThemeProvider configured in root layout with class-based dark mode. Users table has themePreference column with "system" default. html element gets suppressHydrationWarning for next-themes compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add theme toggle to profile page and make editor theme-aware</name>
  <files>src/app/(wiki)/profile/profile-form.tsx, src/app/(wiki)/profile/actions.ts, src/app/(wiki)/profile/page.tsx, src/components/editor/article-editor.tsx</files>
  <action>
**1. Update src/app/(wiki)/profile/actions.ts:**

Add themePreference to the `getUserProfile` function's select fields (add `themePreference: users.themePreference`).

Add a new server action `updateThemePreference`:
```ts
export async function updateThemePreference(theme: string) {
  const session = await auth();
  if (!session?.user?.id) throw new Error("Not authenticated");

  if (!["system", "light", "dark"].includes(theme)) {
    throw new Error("Invalid theme");
  }

  const db = getDb();
  await db.update(users).set({ themePreference: theme }).where(eq(users.id, session.user.id));
}
```

**2. Update src/app/(wiki)/profile/page.tsx:**

Pass `themePreference: user.themePreference` to the ProfileForm component props.

**3. Update src/app/(wiki)/profile/profile-form.tsx:**

Add a theme preference section to the profile form. This should use `next-themes`'s `useTheme` hook for immediate client-side switching AND persist to DB:

a) Add `useTheme` import from `next-themes`
b) Add a new section below the existing profile fields (or in a separate Card passed from page.tsx — match the existing Card pattern):

```tsx
// Theme selection
const { setTheme, theme } = useTheme();
```

Render three toggle buttons (or a radio group) for System / Light / Dark:
```tsx
<div className="space-y-2">
  <Label>Theme</Label>
  <div className="flex gap-2">
    {(["system", "light", "dark"] as const).map((t) => (
      <Button
        key={t}
        variant={theme === t ? "default" : "outline"}
        size="sm"
        onClick={async () => {
          setTheme(t); // Immediate client-side switch
          await updateThemePreference(t); // Persist to DB
        }}
      >
        {t === "system" ? "Auto" : t.charAt(0).toUpperCase() + t.slice(1)}
      </Button>
    ))}
  </div>
  <p className="text-xs text-muted-foreground">
    Auto follows your operating system preference.
  </p>
</div>
```

Import `updateThemePreference` from `./actions`.

c) To load the persisted preference on mount (so it survives login), pass the server-loaded `themePreference` as a prop and call `setTheme(themePreference)` in a useEffect on mount. This syncs the next-themes state with the DB-persisted preference:
```tsx
useEffect(() => {
  if (themePreference) {
    setTheme(themePreference);
  }
}, []); // Only on mount
```

**4. Update src/components/editor/article-editor.tsx:**

Make BlockNote respect the current theme:

a) Import `useTheme` from `next-themes`
b) Get the resolved theme:
```tsx
const { resolvedTheme } = useTheme();
```
c) Replace the hardcoded `theme="light"` on BlockNoteView:
```tsx
<BlockNoteView
  editor={editor}
  onChange={handleChange}
  theme={resolvedTheme === "dark" ? "dark" : "light"}
/>
```

`resolvedTheme` accounts for "system" by resolving to the actual system preference ("light" or "dark").
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Run `npm run build` to verify compilation. Read profile-form.tsx to confirm theme toggle exists. Read article-editor.tsx to confirm BlockNoteView uses resolvedTheme. Read actions.ts to confirm updateThemePreference server action exists.
  </verify>
  <done>
Profile page has System/Light/Dark toggle buttons. Clicking immediately switches theme client-side and persists to users.themePreference in DB. On login, persisted theme is loaded. BlockNote editor switches between light/dark theme based on current resolved theme.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. ThemeProvider with attribute="class" in root layout
4. html element has suppressHydrationWarning
5. Profile page shows System/Light/Dark buttons
6. users table has themePreference column
7. BlockNoteView theme prop uses resolvedTheme
8. updateThemePreference server action validates input
</verification>

<success_criteria>
User can toggle between auto (system default), light, and dark mode from their profile page. Preference persists in the database across sessions. Theme applies app-wide including BlockNote editor. Dark mode uses Tailwind's class strategy via next-themes.
</success_criteria>

<output>
After completion, create `.planning/phases/05-article-editing/05-08-SUMMARY.md`
</output>
