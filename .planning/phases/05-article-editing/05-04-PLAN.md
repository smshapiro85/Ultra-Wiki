---
phase: 05-article-editing
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/ai/review.ts
  - src/lib/merge/conflict.ts
  - src/lib/ai/pipeline.ts
  - src/components/wiki/annotation-banner.tsx
  - src/app/api/articles/[id]/annotations/route.ts
  - src/app/api/articles/[id]/annotations/[annotationId]/dismiss/route.ts
  - src/app/(wiki)/wiki/[articleSlug]/page.tsx
  - src/lib/wiki/queries.ts
autonomous: true
must_haves:
  truths:
    - "After AI merges a human-edited article (clean merge), an LLM reviews for semantic issues and creates annotations"
    - "Annotations never modify article content -- they are stored separately in ai_review_annotations table"
    - "Article page shows collapsible 'AI Review: N items need attention' banner when active annotations exist"
    - "Each annotation shows concern text, referenced section heading, severity, and timestamp"
    - "User can dismiss individual annotations via Dismiss button"
    - "Referenced section headings get a yellow left-border highlight"
    - "Clicking an annotation scrolls to the referenced section"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "ai_review_annotations table and annotationSeverityEnum"
      contains: "aiReviewAnnotations"
    - path: "src/lib/ai/review.ts"
      provides: "LLM review pass generating annotations after merge"
      min_lines: 50
    - path: "src/components/wiki/annotation-banner.tsx"
      provides: "Collapsible annotation banner with cards and dismiss"
      min_lines: 60
    - path: "src/app/api/articles/[id]/annotations/route.ts"
      provides: "GET endpoint for fetching active annotations"
      exports: ["GET"]
    - path: "src/app/api/articles/[id]/annotations/[annotationId]/dismiss/route.ts"
      provides: "POST endpoint for dismissing an annotation"
      exports: ["POST"]
  key_links:
    - from: "src/lib/merge/conflict.ts"
      to: "src/lib/ai/review.ts"
      via: "generateReviewAnnotations call after clean merge"
      pattern: "generateReviewAnnotations"
    - from: "src/components/wiki/annotation-banner.tsx"
      to: "/api/articles/[id]/annotations"
      via: "fetch GET for annotations"
      pattern: "fetch.*annotations"
    - from: "src/components/wiki/annotation-banner.tsx"
      to: "section headings"
      via: "scrollIntoView on annotation click"
      pattern: "scrollIntoView"
---

<objective>
Implement AI review annotations -- the ai_review_annotations table, LLM review pass after merge, collapsible annotation banner UI with section highlighting and dismiss functionality.

Purpose: After AI merges human-edited content, the LLM catches semantic issues (contradictions, stale info) that deterministic merge cannot detect. Annotations give users actionable review items without modifying content.

Output: Database table, LLM review function, pipeline integration, annotation banner component, annotation API routes.
</objective>

<execution_context>
@/Users/michael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-article-editing/05-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/merge/conflict.ts
@src/lib/ai/pipeline.ts
@src/lib/ai/client.ts
@src/lib/content/version.ts
@src/app/(wiki)/wiki/[articleSlug]/page.tsx
@src/lib/wiki/queries.ts
@src/components/wiki/article-content.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ai_review_annotations table, create LLM review function, and integrate into pipeline</name>
  <files>
    src/lib/db/schema.ts
    src/lib/ai/review.ts
    src/lib/merge/conflict.ts
    src/lib/ai/pipeline.ts
  </files>
  <action>
    **A. Add to src/lib/db/schema.ts** (append after existing tables, before end of file):

    1. Add annotationSeverityEnum:
       ```
       export const annotationSeverityEnum = pgEnum("annotation_severity", ["info", "warning", "error"]);
       ```

    2. Add aiReviewAnnotations table:
       ```
       export const aiReviewAnnotations = pgTable(
         "ai_review_annotations",
         {
           id: uuid("id").defaultRandom().primaryKey(),
           articleId: uuid("article_id").notNull().references(() => articles.id, { onDelete: "cascade" }),
           versionId: uuid("version_id").references(() => articleVersions.id, { onDelete: "set null" }),
           sectionHeading: text("section_heading").notNull(),
           concern: text("concern").notNull(),
           severity: annotationSeverityEnum("severity").notNull(),
           isDismissed: boolean("is_dismissed").default(false).notNull(),
           dismissedBy: uuid("dismissed_by").references(() => users.id),
           dismissedAt: timestamp("dismissed_at", { withTimezone: true }),
           createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
         },
         (t) => [index("idx_ai_review_annotations_article").on(t.articleId)]
       );
       ```

    3. Run migration: `npm run db:generate && npm run db:migrate`

    **B. Create src/lib/ai/review.ts** -- LLM review pass:

    - Import getAIModel from @/lib/ai/client
    - Import generateText from "ai"
    - Import Output from "ai" for structured output
    - Import { z } from "zod/v4" (project pattern: Zod v4 via zod/v4 namespace)
    - Import getDb, aiReviewAnnotations from schema

    Define Zod schema for review output:
    ```
    const reviewAnnotationSchema = z.object({
      annotations: z.array(z.object({
        section_heading: z.string().describe("The exact section heading text the concern relates to"),
        concern: z.string().describe("Specific concern about this section after merge"),
        severity: z.enum(["info", "warning", "error"]).describe("info=minor, warning=potential issue, error=likely incorrect"),
      })),
    });
    ```

    Export async function generateReviewAnnotations(params):
    - params: { articleId, versionId?, mergedMarkdown, aiProposedMarkdown, humanMarkdown, changeSummary }
    - Build prompt: "You are reviewing a wiki article after an automated merge of AI-generated content with human edits. Analyze the merged content for semantic issues..."
      * Provide the merged content, the original AI proposal, and the human version
      * Ask: identify contradictions, stale information from human edits that conflicts with code changes, sections where AI and human content may be semantically inconsistent
      * Instruct: only flag genuine concerns, not stylistic differences. Each annotation MUST reference an exact section heading from the merged content. If no concerns, return empty annotations array.
    - Call generateText with experimental_output: Output.object({ schema: reviewAnnotationSchema })
    - Parse response, insert annotations into ai_review_annotations table:
      For each annotation in result:
      ```
      await db.insert(aiReviewAnnotations).values({
        articleId: params.articleId,
        versionId: params.versionId ?? null,
        sectionHeading: annotation.section_heading,
        concern: annotation.concern,
        severity: annotation.severity,
      });
      ```
    - Wrap in try/catch -- annotation generation failure should NOT fail the merge. Log error and continue.

    **C. Update src/lib/merge/conflict.ts** -- trigger review after clean merge:

    IMPORTANT: Use dynamic import for the review module (same pattern as pipeline.ts) to avoid pulling AI dependencies into the module graph at evaluation time.

    In the resolveConflict function, AFTER the clean merge return (the `else` branch at the bottom), add a call to generate annotations:
    - This requires adding articleId, currentMarkdown, aiProposedMarkdown to the params (they are already there)
    - Add a new optional param `triggerReview?: boolean` (default false)
    - When triggerReview is true and the merge is clean (no conflicts):
      ```
      // Fire-and-forget: annotation generation should not block merge completion
      // But we await it since it's fast and annotations should be available immediately
      try {
        const { generateReviewAnnotations } = await import("@/lib/ai/review");
        await generateReviewAnnotations({
          articleId,
          mergedMarkdown: mergeResult.mergedMarkdown,
          aiProposedMarkdown,
          humanMarkdown: currentMarkdown,
          changeSummary,
        });
      } catch (err) {
        console.error("[resolveConflict] Annotation generation failed:", err);
      }
      ```

    **D. Update src/lib/ai/pipeline.ts** -- pass triggerReview: true:

    In the processUpdateArticle function, when calling resolveConflict for human-edited articles, add triggerReview: true to the params object. This ensures the LLM review runs after every clean merge of human-edited articles.

    Also, pass the versionId to generateReviewAnnotations if available (the version is created after resolveConflict returns, so we need to restructure slightly):
    - After resolveConflict returns and the clean merge version is created via createArticleVersion, call generateReviewAnnotations separately with the versionId.
    - OR: keep it simpler -- trigger review inside resolveConflict without versionId (it's optional), then the version is created afterward. The versionId link is a nice-to-have, not critical.

    Choose the simpler approach: trigger in resolveConflict, versionId is null. The annotation still references the articleId which is sufficient for querying.
  </action>
  <verify>
    Run `npm run db:generate` -- migration file created for ai_review_annotations.
    Run `npm run db:migrate` -- migration applies successfully.
    Run `npx tsc --noEmit` -- no type errors.
    Verify ai_review_annotations table exists in generated SQL.
  </verify>
  <done>
    ai_review_annotations table created with severity enum, LLM review function generates annotations from merged content, pipeline triggers review after clean merge of human-edited articles. Annotation generation failure does not abort merges.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create annotation banner UI, API routes, and section highlighting</name>
  <files>
    src/app/api/articles/[id]/annotations/route.ts
    src/app/api/articles/[id]/annotations/[annotationId]/dismiss/route.ts
    src/components/wiki/annotation-banner.tsx
    src/app/(wiki)/wiki/[articleSlug]/page.tsx
    src/lib/wiki/queries.ts
  </files>
  <action>
    **A. Create GET /api/articles/[id]/annotations/route.ts**:

    - No auth required (annotations are part of article view)
    - Query ai_review_annotations WHERE articleId = id AND isDismissed = false, ORDER BY createdAt DESC
    - Return array: { id, sectionHeading, concern, severity, createdAt }

    **B. Create POST /api/articles/[id]/annotations/[annotationId]/dismiss/route.ts**:

    - Auth guard: require authenticated session
    - Update ai_review_annotations SET isDismissed = true, dismissedBy = session.user.id, dismissedAt = new Date() WHERE id = annotationId AND articleId = id
    - If no rows updated, return 404
    - Return 200 { success: true }

    **C. Create src/components/wiki/annotation-banner.tsx** (client component):

    A collapsible banner that:
    - Props: articleId (string)
    - On mount, fetch active annotations from /api/articles/${articleId}/annotations
    - If no annotations, render nothing
    - Render a collapsible banner (use shadcn Collapsible):
      * Header: amber/yellow background, "AI Review: {count} items need attention" with ChevronDown toggle icon and AlertTriangle icon
      * Default: collapsed (showing just the header bar)
      * Expanded: list of annotation cards
    - Each annotation card:
      * Severity icon: Info (blue circle-i), Warning (amber triangle), Error (red octagon)
      * Section heading as a clickable link (onClick scrolls to section)
      * Concern text
      * Timestamp (relative, like "2 hours ago" via Intl.RelativeTimeFormat or simple date)
      * Dismiss button (X icon) -- on click, POST to dismiss endpoint, remove from local state
    - Section scrolling: onClick handler finds the heading element by ID. The article page already generates heading IDs via the shared slugify function. Convert sectionHeading to slug (using the same slugify logic from table-of-contents.tsx -- import it or replicate the simple logic: lowercase, replace non-alphanumeric with hyphens, trim). Then document.getElementById(slug)?.scrollIntoView({ behavior: "smooth", block: "start" }).
    - Dismiss handler: POST to /api/articles/${articleId}/annotations/${annotationId}/dismiss, on success remove from local state (optimistic update), toast "Annotation dismissed"

    **D. Add section highlighting CSS**:

    The annotation banner needs to add yellow left-border highlights to referenced section headings. Approach:
    - In annotation-banner.tsx, after fetching annotations, use a useEffect to add a CSS class to matched heading elements:
      * For each annotation's sectionHeading, compute the slug, find the element by ID
      * Add class "annotation-highlight" to it
      * On cleanup (or when annotations change), remove the classes
    - In globals.css (or inline in the component), add:
      ```css
      .annotation-highlight {
        border-left: 3px solid oklch(0.828 0.189 84.429); /* amber/yellow */
        padding-left: 0.5rem;
      }
      ```
    - Alternative: use inline styles in the useEffect instead of CSS class to avoid globals.css modification. Either approach works -- inline is simpler and self-contained.

    **E. Update src/app/(wiki)/wiki/[articleSlug]/page.tsx**:

    - Import AnnotationBanner
    - Add the banner below the review banner (the existing amber needsReview banner) and above the tabs:
      ```
      <AnnotationBanner articleId={article.id} />
      ```
    - The AnnotationBanner handles its own data fetching and renders nothing when no annotations exist.

    **F. Add getActiveAnnotationCount to src/lib/wiki/queries.ts** (optional helper):

    If the article page needs a server-side annotation count for the banner header (to avoid a loading flash), add:
    ```
    export async function getActiveAnnotationCount(articleId: string): Promise<number> {
      const db = getDb();
      const result = await db.select({ count: sql<number>`count(*)` })
        .from(aiReviewAnnotations)
        .where(and(eq(aiReviewAnnotations.articleId, articleId), eq(aiReviewAnnotations.isDismissed, false)));
      return Number(result[0].count);
    }
    ```
    Pass this count as a prop to AnnotationBanner for instant rendering. The banner can still fetch full annotation details client-side, but the count is known immediately from the server component.
  </action>
  <verify>
    Run `npm run build` -- should compile without errors.
    The annotation API routes exist.
    The AnnotationBanner component renders on the article page.
  </verify>
  <done>
    Article page shows collapsible "AI Review: N items need attention" banner when active annotations exist.
    Each annotation card shows severity icon, section heading (clickable to scroll), concern text, timestamp, and Dismiss button.
    Dismissing removes the annotation from the UI and marks it dismissed in the database.
    Referenced section headings get a yellow left-border highlight.
    When no annotations exist, banner does not render.
  </done>
</task>

</tasks>

<verification>
1. After AI merge of a human-edited article, check ai_review_annotations table -- annotations created
2. Visit the article page -- "AI Review: N items need attention" banner appears (collapsed)
3. Expand banner -- annotation cards visible with severity, section, concern, timestamp
4. Click a section heading link -- page scrolls to that section
5. Verify yellow left-border on referenced section headings
6. Click Dismiss on an annotation -- removed from UI, marked dismissed in DB
7. After all dismissed -- banner disappears
8. Verify annotation generation failure does not block merge (check error logging)
</verification>

<success_criteria>
- ai_review_annotations table exists with annotationSeverityEnum
- LLM review generates annotations after clean merge of human-edited articles
- Annotation generation failure is caught and logged, not propagated
- Banner shows on article page with correct count of active annotations
- Each annotation card has severity, section heading, concern, timestamp, dismiss
- Clicking section heading scrolls to that section in the article
- Section headings with annotations have yellow left-border highlight
- Dismiss updates database and removes from UI
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-article-editing/05-04-SUMMARY.md`
</output>
