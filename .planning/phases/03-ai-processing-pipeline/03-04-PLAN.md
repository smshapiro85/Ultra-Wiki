---
phase: 03-ai-processing-pipeline
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: ["src/lib/ai/pipeline.ts"]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After sync completes, articles table contains new rows with AI-generated content, title, slug, contentJson, and category assignment"
    - "pipeline.ts never statically imports @blocknote/server-util (even transitively via markdown.ts)"
  artifacts:
    - path: "src/lib/ai/pipeline.ts"
      provides: "AI pipeline orchestrator with dynamic markdown imports"
      contains: "await import"
  key_links:
    - from: "src/lib/ai/pipeline.ts"
      to: "src/lib/content/markdown.ts"
      via: "dynamic import() at each call site"
      pattern: "await import.*content/markdown"
---

<objective>
Fix the createContext crash that prevents the AI pipeline from creating articles.

Purpose: pipeline.ts has a static `import { blocksToMarkdown, markdownToBlocks } from "@/lib/content/markdown"` on line 26. This pulls in @blocknote/server-util at module evaluation time, which triggers a JSDOM createContext error in the RSC/Turbopack environment. Even though sync.ts dynamically imports pipeline.ts, the static import inside pipeline.ts defeats the lazy loading -- the entire @blocknote/server-util module graph is evaluated the moment pipeline.ts is imported. The fix: remove the static import and use dynamic `import()` at each call site within pipeline.ts, exactly mirroring the pattern sync.ts already uses for pipeline.ts itself.

Output: A working pipeline that creates articles and article versions after sync.
</objective>

<execution_context>
@/Users/michael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-processing-pipeline/03-UAT.md
@src/lib/ai/pipeline.ts
@src/lib/content/markdown.ts
@src/lib/github/sync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace static markdown.ts import with dynamic imports in pipeline.ts</name>
  <files>src/lib/ai/pipeline.ts</files>
  <action>
In src/lib/ai/pipeline.ts, make these exact changes:

1. DELETE line 26 entirely:
   ```
   import { blocksToMarkdown, markdownToBlocks } from "@/lib/content/markdown";
   ```

2. At each of the 4 call sites, replace the bare function call with a dynamic import + destructure. The pattern for each is:
   ```typescript
   const { functionName } = await import("@/lib/content/markdown");
   ```
   immediately before the function call.

   The 4 call sites to update:

   a. In processCreateArticle (~line 235):
      BEFORE: `const contentJson = await markdownToBlocks(contentMarkdown);`
      AFTER:
      ```typescript
      const { markdownToBlocks } = await import("@/lib/content/markdown");
      const contentJson = await markdownToBlocks(contentMarkdown);
      ```

   b. In processUpdateArticle, AI-only overwrite branch (~line 346):
      BEFORE: `const contentJson = await markdownToBlocks(contentMarkdown);`
      AFTER:
      ```typescript
      const { markdownToBlocks } = await import("@/lib/content/markdown");
      const contentJson = await markdownToBlocks(contentMarkdown);
      ```

   c. In processUpdateArticle, human-edited branch, JSON-to-markdown conversion (~line 379):
      BEFORE: `currentMarkdown = await blocksToMarkdown(existing.contentJson);`
      AFTER:
      ```typescript
      const { blocksToMarkdown } = await import("@/lib/content/markdown");
      currentMarkdown = await blocksToMarkdown(existing.contentJson);
      ```

   d. In processUpdateArticle, human-edited branch, after merge resolution (~line 405):
      BEFORE: `const finalContentJson = await markdownToBlocks(resolution.finalMarkdown);`
      AFTER:
      ```typescript
      const { markdownToBlocks: markdownToBlocksFinal } = await import("@/lib/content/markdown");
      const finalContentJson = await markdownToBlocksFinal(resolution.finalMarkdown);
      ```
      NOTE: Use the alias `markdownToBlocksFinal` for the second destructure in the same function scope to avoid shadowing the variable from call site (b) if they share the same function scope. Actually -- reviewing the code more carefully: call site (b) is inside the `if (!existing.hasHumanEdits)` branch and call sites (c) and (d) are inside the `else` branch. So (b) and (d) are in different blocks and won't shadow each other. BUT (c) and (d) ARE in the same `else` block. Since `blocksToMarkdown` (c) and `markdownToBlocks` (d) are different function names, there is no shadowing conflict. No alias needed for any of them.

      Corrected (d):
      ```typescript
      const { markdownToBlocks } = await import("@/lib/content/markdown");
      const finalContentJson = await markdownToBlocks(resolution.finalMarkdown);
      ```

3. Do NOT touch any other imports in the file. All other imports (drizzle-orm, schema, settings, analyze, generate, merge, version) are safe static imports -- they do not transitively pull in @blocknote/server-util.

4. Add a comment where the old static import was:
   ```typescript
   // blocksToMarkdown and markdownToBlocks are dynamically imported at call
   // sites below to avoid pulling @blocknote/server-util into the module graph
   // at evaluation time (causes createContext crash in RSC/Turbopack).
   ```
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors.
Run `grep -n "from.*content/markdown" src/lib/ai/pipeline.ts` -- should show only dynamic import() lines, no static import line.
Run `grep -c "await import.*content/markdown" src/lib/ai/pipeline.ts` -- should output 4 (one per call site).
Run the dev server with `npx next dev --turbopack` and hit the manual sync endpoint to confirm articles are created.
  </verify>
  <done>
pipeline.ts has zero static imports of markdown.ts. All 4 usages of blocksToMarkdown/markdownToBlocks use dynamic import(). TypeScript compiles without errors. The AI pipeline successfully creates articles and article versions when triggered by sync (no createContext crash).
  </done>
</task>

</tasks>

<verification>
1. `grep "from.*@/lib/content/markdown" src/lib/ai/pipeline.ts` returns ZERO static import lines
2. `grep -c "await import.*content/markdown" src/lib/ai/pipeline.ts` returns 4
3. `npx tsc --noEmit` passes
4. Manual sync creates rows in both `articles` and `article_versions` tables (the UAT Test 1 scenario)
</verification>

<success_criteria>
- The static import of markdown.ts is removed from pipeline.ts
- All 4 call sites use dynamic import() pattern
- TypeScript compiles cleanly
- The createContext crash no longer occurs when the AI pipeline runs
- Articles and article versions are created in the database after sync
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-processing-pipeline/03-04-SUMMARY.md`
</output>
