---
phase: 08-ai-prompt-refinement
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/(admin)/admin/sync/sync-trigger.tsx
  - src/app/api/sync/stream/route.ts
  - src/lib/github/sync.ts
  - src/app/(admin)/admin/sync/file-tree.tsx
autonomous: true
gap_closure: false

must_haves:
  truths:
    - "When a manual sync is triggered, a live log panel appears in the Manual Sync card showing real-time progress messages"
    - "Log messages include high-level steps: connecting to GitHub, fetching file tree, downloading files (with count), analyzing with AI, creating/updating articles, sync complete"
    - "The log panel auto-scrolls to the latest message as new entries appear"
    - "The log does not persist — it resets when the page is refreshed or a new sync starts"
    - "The file tree defaults to all top-level folders collapsed (not expanded)"
    - "Expand All and Collapse All buttons appear above the file tree"
    - "A search box above the file tree filters the tree to show matching files/folders and their ancestor paths"
    - "Selecting a folder while searching selects all child files and folders (including those hidden by the filter)"
  artifacts:
    - path: "src/app/api/sync/stream/route.ts"
      provides: "SSE endpoint that triggers sync and streams log events to the client"
    - path: "src/app/(admin)/admin/sync/sync-trigger.tsx"
      provides: "Updated SyncTrigger with live log panel consuming SSE stream"
    - path: "src/app/(admin)/admin/sync/file-tree.tsx"
      provides: "File tree with expand/collapse all, default collapsed, search filter"
  key_links:
    - from: "src/app/(admin)/admin/sync/sync-trigger.tsx"
      to: "src/app/api/sync/stream/route.ts"
      via: "EventSource connection for live log streaming"
      pattern: "EventSource"
    - from: "src/app/api/sync/stream/route.ts"
      to: "src/lib/github/sync.ts"
      via: "runSync with onLog callback for progress events"
      pattern: "runSync"
---

<objective>
Two sync page improvements:

1. **Live sync log**: When manual sync runs, show a real-time log panel in the Manual Sync card. Uses Server-Sent Events (SSE) to stream progress from the sync process to the client. Log shows high-level steps (not every API call) so the admin can see where the process is.

2. **File tree enhancements**: Default to collapsed, add Expand All / Collapse All buttons, and add a search box that filters the tree while preserving folder selection behavior for hidden children.

Purpose: Admin has visibility into what sync is doing (especially during long runs) and can efficiently navigate large file trees.
Output: SSE sync stream endpoint, updated SyncTrigger with log panel, updated FileTree with controls and search.
</objective>

<execution_context>
@/Users/michael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/app/(admin)/admin/sync/sync-trigger.tsx
@src/app/(admin)/admin/sync/file-tree.tsx
@src/app/(admin)/admin/sync/actions.ts
@src/app/(admin)/admin/sync/page.tsx
@src/lib/github/sync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add onLog callback to sync engine and create SSE stream endpoint</name>
  <files>src/lib/github/sync.ts, src/app/api/sync/stream/route.ts</files>
  <action>
**1. Add an optional `onLog` callback to the sync function in src/lib/github/sync.ts:**

Update the `runSync` function signature to accept an optional logging callback:

```ts
interface SyncOptions {
  onLog?: (message: string) => void;
}
```

Add `onLog` calls at key milestones throughout the sync process. These should be high-level, human-readable messages:

- `"Connecting to GitHub..."` — before the first GitHub API call
- `"Fetching repository file tree..."` — before fetching the tree
- `"File tree loaded: {N} files found"` — after tree fetch
- `"Downloading {N} changed files..."` — before content download loop
- `"Downloaded: {path}"` — for each file downloaded (or batch: `"Downloaded {N}/{total} files"`)
- `"Running AI analysis on {N} files..."` — before AI pipeline call
- `"AI analysis complete: {N} articles to create/update"` — after analysis
- `"Creating article: {title}"` or `"Updating article: {title}"` — per article
- `"Generating file summaries..."` — before summary generation
- `"Sync complete: {N} files processed, {M} articles updated"` — final message

The callback is optional — existing callers (cron endpoint) don't need to pass it. Use `options?.onLog?.("message")` pattern so it's a no-op when not provided.

**2. Create src/app/api/sync/stream/route.ts:**

A GET endpoint that:
- Verifies the user is an admin (session check)
- Creates a ReadableStream that:
  - Calls `runSync` with an `onLog` callback
  - Each `onLog` call writes an SSE event: `data: {message}\n\n`
  - On completion, sends a final `event: done\ndata: complete\n\n` and closes the stream
  - On error, sends `event: error\ndata: {message}\n\n` and closes

```ts
import { auth } from "@/lib/auth";
import { runSync } from "@/lib/github/sync";

export async function GET() {
  const session = await auth();
  if (!session?.user || session.user.role !== "admin") {
    return new Response("Unauthorized", { status: 401 });
  }

  const stream = new ReadableStream({
    async start(controller) {
      const encoder = new TextEncoder();
      const send = (event: string, data: string) => {
        controller.enqueue(encoder.encode(`event: ${event}\ndata: ${data}\n\n`));
      };

      try {
        send("log", "Starting sync...");
        await runSync({
          onLog: (message) => send("log", message),
        });
        send("done", "complete");
      } catch (error) {
        send("error", error instanceof Error ? error.message : "Sync failed");
      } finally {
        controller.close();
      }
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}
```

Note: The existing `triggerManualSync` server action in actions.ts still works. The SSE endpoint is a parallel path used only by the SyncTrigger component for live logging. The cron endpoint and any other callers are unaffected.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Read sync.ts to confirm onLog calls at key milestones. Read the stream route to confirm SSE format with event types (log, done, error).
  </verify>
  <done>
Sync engine emits high-level progress messages via optional onLog callback. SSE endpoint at /api/sync/stream triggers sync and streams log events to the client. Existing sync callers are unaffected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add live log panel to SyncTrigger component</name>
  <files>src/app/(admin)/admin/sync/sync-trigger.tsx</files>
  <action>
**Update src/app/(admin)/admin/sync/sync-trigger.tsx:**

Replace the current polling-based sync trigger with an SSE-based approach that shows a live log:

a) **Add log state:**
```ts
const [logs, setLogs] = useState<string[]>([]);
const logEndRef = useRef<HTMLDivElement>(null);
```

b) **Replace handleSync to use EventSource:**
```ts
const handleSync = useCallback(() => {
  setState({ phase: "running", syncLogId: "" });
  setLogs([]);

  const source = new EventSource("/api/sync/stream");

  source.addEventListener("log", (e) => {
    setLogs((prev) => [...prev, e.data]);
  });

  source.addEventListener("done", () => {
    source.close();
    setState({
      phase: "completed",
      stats: { filesProcessed: 0, added: 0, modified: 0, removed: 0 },
    });
  });

  source.addEventListener("error", (e) => {
    source.close();
    // Check if it's an SSE MessageEvent with data or a generic error
    const message = (e as MessageEvent)?.data || "Sync failed";
    setState({ phase: "error", message });
  });
}, []);
```

c) **Auto-scroll log panel:**
```ts
useEffect(() => {
  logEndRef.current?.scrollIntoView({ behavior: "smooth" });
}, [logs]);
```

d) **Render the live log panel** below the button, visible when running or when logs exist:
```tsx
{(state.phase === "running" || logs.length > 0) && (
  <div className="rounded-md border border-zinc-200 bg-zinc-950 dark:border-zinc-700 p-3 font-mono text-xs text-zinc-300 max-h-64 overflow-y-auto">
    {logs.map((log, i) => (
      <div key={i} className="py-0.5">
        <span className="text-zinc-500 mr-2">{String(i + 1).padStart(2, "0")}</span>
        {log}
      </div>
    ))}
    {state.phase === "running" && (
      <div className="py-0.5 animate-pulse text-zinc-500">...</div>
    )}
    <div ref={logEndRef} />
  </div>
)}
```

The log panel has a dark terminal-like appearance, monospace font, line numbers, max height with scroll, and auto-scrolls as new entries arrive. It resets when a new sync starts and persists on screen after completion (until page refresh or next sync).

Remove the old polling logic (the `setInterval` / `getSyncStatus` code) since the SSE stream handles completion/error detection.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Run `npm run build` to verify compilation. Read sync-trigger.tsx to confirm: EventSource connection to /api/sync/stream, log state array, auto-scrolling log panel, no polling logic remains.
  </verify>
  <done>
SyncTrigger shows a live terminal-style log panel when sync runs. Messages stream in real-time via SSE. Panel auto-scrolls, shows line numbers, and has a dark monospace appearance. Completion and errors detected via SSE events (no polling).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add expand/collapse all, default collapsed, and search to file tree</name>
  <files>src/app/(admin)/admin/sync/file-tree.tsx</files>
  <action>
**Update src/app/(admin)/admin/sync/file-tree.tsx:**

**1. Default to collapsed:**

Change the `defaultExpanded` prop on the top-level TreeNodeItem from `true` to `false`:
```tsx
// In the FileTree component's ScrollArea mapping:
<TreeNodeItem
  key={node.path}
  node={node}
  includedSet={includedPaths}
  onToggle={handleToggle}
  depth={0}
  defaultExpanded={false}  // was true
/>
```

**2. Add expand/collapse all with a key-based reset approach:**

Add state to control expand/collapse all:
```ts
const [expandKey, setExpandKey] = useState(0);
const [expandAll, setExpandAll] = useState(false);
```

When "Expand All" is clicked, set `expandAll = true` and increment `expandKey`. When "Collapse All" is clicked, set `expandAll = false` and increment `expandKey`. The `expandKey` is passed as a React `key` prop to force re-mount of all TreeNodeItem components, resetting their local `expanded` state to the new `defaultExpanded` value.

```tsx
<div className="flex items-center gap-2">
  <Button
    variant="ghost"
    size="sm"
    onClick={() => { setExpandAll(true); setExpandKey((k) => k + 1); }}
  >
    <ChevronsDownUp className="mr-1 h-3.5 w-3.5" />
    Expand All
  </Button>
  <Button
    variant="ghost"
    size="sm"
    onClick={() => { setExpandAll(false); setExpandKey((k) => k + 1); }}
  >
    <ChevronsUpDown className="mr-1 h-3.5 w-3.5" />
    Collapse All
  </Button>
</div>
```

Import `ChevronsDownUp` and `ChevronsUpDown` from lucide-react (or use `FoldVertical`/`UnfoldVertical`).

Pass the key to the tree container:
```tsx
<div key={expandKey}>
  {filteredTree.map((node) => (
    <TreeNodeItem
      key={node.path}
      node={node}
      includedSet={includedPaths}
      onToggle={handleToggle}
      depth={0}
      defaultExpanded={expandAll}
    />
  ))}
</div>
```

**3. Add search box:**

Add search state:
```ts
const [searchQuery, setSearchQuery] = useState("");
```

Add a search input above the tree (below the expand/collapse buttons):
```tsx
<Input
  placeholder="Search files and folders..."
  value={searchQuery}
  onChange={(e) => setSearchQuery(e.target.value)}
  className="h-8 text-sm"
/>
```

Import `Input` from `@/components/ui/input`.

**Filter the tree based on search:**

Create a recursive filter function that:
- If a node's name matches the query (case-insensitive), include it and all its descendants
- If any descendant matches, include the node (as an ancestor path) but only with matching children
- Non-matching nodes with no matching descendants are excluded

```ts
function filterTree(nodes: TreeNode[], query: string): TreeNode[] {
  if (!query) return nodes;
  const lower = query.toLowerCase();

  return nodes
    .map((node) => {
      const nameMatches = node.name.toLowerCase().includes(lower);
      const pathMatches = node.path.toLowerCase().includes(lower);

      if (node.type === "file") {
        return nameMatches || pathMatches ? node : null;
      }

      // Directory: check if any children match
      const filteredChildren = node.children
        ? filterTree(node.children, query)
        : [];

      if (nameMatches || pathMatches || filteredChildren.length > 0) {
        return {
          ...node,
          children: nameMatches ? node.children : filteredChildren,
        };
      }
      return null;
    })
    .filter(Boolean) as TreeNode[];
}
```

When searching, auto-expand matching nodes by passing `defaultExpanded={true}` and incrementing the key:
```ts
// In a useEffect watching searchQuery:
useEffect(() => {
  if (searchQuery) {
    setExpandAll(true);
    setExpandKey((k) => k + 1);
  }
}, [searchQuery]);
```

Use `const filteredTree = filterTree(tree, searchQuery)` in the render.

**4. Ensure folder selection during search selects all children (including hidden ones):**

The existing `handleToggle` function uses `collectAllPaths(node)` which traverses the ORIGINAL node's children, not the filtered tree's children. This is correct — when the user selects a folder in the filtered view, the toggle operates on the original full node, so all children (including those hidden by the filter) get selected.

Verify this by reading the `collectAllPaths` function — it operates on the node passed from the tree data, which is the original node reference (filtering creates shallow copies of the node objects with filtered children, but the `onToggle` callback receives the actual node).

Actually, the filtered tree creates new node objects with `{ ...node, children: filteredChildren }`. So when a filtered folder is toggled, `collectAllPaths` only sees the filtered children. To fix this:

- Keep a Map of original nodes by path:
```ts
const originalNodeMap = useRef(new Map<string, TreeNode>());
useEffect(() => {
  function buildMap(nodes: TreeNode[]) {
    for (const node of nodes) {
      originalNodeMap.current.set(node.path, node);
      if (node.children) buildMap(node.children);
    }
  }
  originalNodeMap.current.clear();
  buildMap(tree);
}, [tree]);
```

- Update `handleToggle` to use the original node:
```ts
const handleToggle = useCallback((node: TreeNode, checked: boolean) => {
  // Always use the original (unfiltered) node for path collection
  const originalNode = originalNodeMap.current.get(node.path) ?? node;
  setIncludedPaths((prev) => {
    const next = new Set(prev);
    const allPaths = collectAllPaths(originalNode);
    // ... rest of existing logic unchanged
  });
}, []);
```

This ensures that selecting a folder while searching always includes ALL children, not just the visible filtered ones.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Run `npm run build` to verify compilation. Read file-tree.tsx to confirm:
1. Top-level folders default to collapsed (defaultExpanded={false})
2. Expand All / Collapse All buttons exist
3. Search input filters the tree
4. filterTree function preserves ancestor paths for matches
5. handleToggle uses original (unfiltered) node for path collection via originalNodeMap
6. Search auto-expands the filtered tree
  </verify>
  <done>
File tree defaults to collapsed. Expand All / Collapse All buttons toggle all top-level folders. Search box filters the tree by file/folder name, auto-expanding matches. Selecting a folder while searching selects ALL children (including those hidden by the filter) via originalNodeMap lookup.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Live log panel appears in Manual Sync card during sync with streaming messages
4. Log shows high-level steps: connecting, fetching tree, downloading files, AI analysis, article creation, complete
5. Log auto-scrolls and has terminal-style dark appearance
6. File tree top-level folders default to collapsed
7. Expand All / Collapse All buttons work
8. Search input filters files/folders, showing ancestor paths for matches
9. Folder selection during search selects all children including hidden ones
10. SSE endpoint at /api/sync/stream requires admin auth
</verification>

<success_criteria>
Admin can see real-time sync progress in a live log panel. File tree defaults to collapsed with expand/collapse all controls and a search filter. Folder selection during search correctly cascades to all children.
</success_criteria>

<output>
After completion, create `.planning/phases/08-ai-prompt-refinement/08-04-SUMMARY.md`
</output>
