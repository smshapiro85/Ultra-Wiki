---
phase: 01-foundation-and-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - next.config.ts
  - tsconfig.json
  - tailwind.config.ts
  - src/lib/db/schema.ts
  - src/lib/db/index.ts
  - src/lib/db/migrate.ts
  - src/lib/db/seed.ts
  - drizzle.config.ts
  - Dockerfile
  - docker-compose.yml
  - .env.example
  - .dockerignore
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Project builds successfully with `npm run build`"
    - "Drizzle migration generates SQL for all 14+ tables"
    - "Database schema includes all Auth.js required tables plus all application tables"
    - "Docker image builds and runs with `docker compose up`"
    - "Application connects to Neon Postgres via HTTP (pooled) and TCP (unpooled) drivers"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Complete Drizzle schema with all 14+ tables"
      contains: "pgTable"
    - path: "src/lib/db/index.ts"
      provides: "Neon HTTP database client singleton"
      contains: "neon"
    - path: "src/lib/db/migrate.ts"
      provides: "TCP-based migration runner"
      contains: "Pool"
    - path: "src/lib/db/seed.ts"
      provides: "site_settings seed script"
      contains: "siteSettings"
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit configuration"
      contains: "defineConfig"
    - path: "Dockerfile"
      provides: "Multi-stage Docker build"
      contains: "standalone"
    - path: "docker-compose.yml"
      provides: "Docker Compose config with image volume"
      contains: "image_data"
  key_links:
    - from: "src/lib/db/index.ts"
      to: "src/lib/db/schema.ts"
      via: "schema import for relational queries"
      pattern: "import.*schema"
    - from: "drizzle.config.ts"
      to: "src/lib/db/schema.ts"
      via: "schema path reference"
      pattern: "schema.*schema\\.ts"
    - from: "src/lib/db/migrate.ts"
      to: "DATABASE_URL_UNPOOLED"
      via: "pg Pool with direct connection"
      pattern: "DATABASE_URL_UNPOOLED"
---

<objective>
Scaffold the entire Next.js 15 project from scratch, define the complete database schema for all 7 phases in Drizzle ORM, and set up Docker deployment infrastructure.

Purpose: This is the absolute foundation -- every subsequent plan and phase depends on the project structure, database schema, and deployment config created here.
Output: A buildable Next.js 15 project with complete Drizzle schema (14+ tables), Docker deployment files, and dual Neon Postgres connection setup.
</objective>

<execution_context>
@/Users/michael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Next.js 15 project with all Phase 1 dependencies and Docker infrastructure</name>
  <files>
    package.json
    next.config.ts
    tsconfig.json
    Dockerfile
    docker-compose.yml
    .env.example
    .dockerignore
    .gitignore
    src/app/layout.tsx
    src/app/page.tsx
    src/lib/utils.ts
    components.json
  </files>
  <action>
    1. Scaffold the Next.js 15 project in the current repo root (Ultra-Wiki):
       ```
       npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --yes
       ```
       If the directory is not empty (due to .planning/ and docs/), move those aside temporarily, scaffold, then move back. Or use `--yes` to force.

    2. Initialize shadcn/ui:
       ```
       npx shadcn@latest init --defaults
       ```
       This sets up the components.json and Tailwind v4 CSS-first config.

    3. Install all Phase 1 dependencies:
       ```
       npm install drizzle-orm @neondatabase/serverless pg next-auth@beta @auth/drizzle-adapter zod
       npm install -D drizzle-kit @types/pg
       ```

    4. Update `next.config.ts` to use standalone output:
       ```typescript
       import type { NextConfig } from "next";

       const nextConfig: NextConfig = {
         output: "standalone",
       };

       export default nextConfig;
       ```

    5. Create `.env.example` with all required environment variables:
       ```
       # Database (Neon Postgres)
       DATABASE_URL=postgresql://user:pass@ep-xxx-pooler.region.aws.neon.tech/neondb?sslmode=require
       DATABASE_URL_UNPOOLED=postgresql://user:pass@ep-xxx.region.aws.neon.tech/neondb?sslmode=require

       # Auth.js
       AUTH_SECRET=generate-with-openssl-rand-base64-32
       AUTH_GOOGLE_ID=your-google-client-id
       AUTH_GOOGLE_SECRET=your-google-client-secret
       AUTH_URL=http://localhost:3000

       # App
       NEXT_PUBLIC_APP_URL=http://localhost:3000
       ```

    6. Create `Dockerfile` using the multi-stage build pattern from research:
       - Base: `node:22-alpine`
       - Stage 1 (deps): Copy package*.json, run `npm ci`
       - Stage 2 (builder): Copy source, run `npm run build`
       - Stage 3 (runner): Copy standalone output, create `/data/images` with correct ownership, run as non-root `nextjs` user
       - Set `NEXT_TELEMETRY_DISABLED=1`, `NODE_ENV=production`, expose port 3000
       - Use the exact Dockerfile from research Pattern 5

    7. Create `docker-compose.yml`:
       ```yaml
       services:
         app:
           build: .
           ports:
             - "3000:3000"
           volumes:
             - image_data:/data/images
           env_file:
             - .env
           restart: unless-stopped

       volumes:
         image_data:
           driver: local
       ```

    8. Create `.dockerignore`:
       ```
       node_modules
       .next
       .git
       .planning
       docs
       drizzle
       .env
       .env.local
       ```

    9. Update `.gitignore` to include:
       ```
       .env
       .env.local
       drizzle/*.sql
       ```

    10. Verify the project builds: `npm run build`
  </action>
  <verify>
    Run `npm run build` -- must complete without errors.
    Run `ls .next/standalone/server.js` -- must exist (standalone output).
    Run `docker build -t ultra-wiki-test .` -- must build successfully (if Docker available, otherwise skip).
  </verify>
  <done>
    Next.js 15 project scaffolded with all Phase 1 deps installed, shadcn/ui initialized, Docker multi-stage build working, standalone output confirmed, .env.example documents all required vars.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define complete Drizzle schema with all 14+ tables and create migration infrastructure</name>
  <files>
    src/lib/db/schema.ts
    src/lib/db/index.ts
    src/lib/db/migrate.ts
    src/lib/db/seed.ts
    drizzle.config.ts
  </files>
  <action>
    1. Create `drizzle.config.ts` at project root:
       ```typescript
       import { defineConfig } from "drizzle-kit";

       export default defineConfig({
         schema: "./src/lib/db/schema.ts",
         out: "./drizzle",
         dialect: "postgresql",
         dbCredentials: {
           url: process.env.DATABASE_URL_UNPOOLED!,
         },
       });
       ```

    2. Create `src/lib/db/index.ts` -- Application database client using Neon HTTP driver:
       ```typescript
       import { drizzle } from "drizzle-orm/neon-http";
       import { neon } from "@neondatabase/serverless";
       import * as schema from "./schema";

       const sql = neon(process.env.DATABASE_URL!);
       export const db = drizzle({ client: sql, schema });
       ```

    3. Create `src/lib/db/schema.ts` with ALL tables from the spec. This is the largest file. Include:

       **Enums (6):**
       - `roleEnum`: ["admin", "user"]
       - `changeSourceEnum`: ["ai_generated", "ai_updated", "human_edited", "ai_merged"]
       - `syncStatusEnum`: ["running", "completed", "failed"]
       - `triggerTypeEnum`: ["scheduled", "manual"]
       - `aiConversationModeEnum`: ["global", "page"]
       - `aiMessageRoleEnum`: ["user", "assistant"]

       **Custom types:**
       - `tsvector` using `customType` from drizzle-orm/pg-core

       **Auth.js tables (4):**
       - `users`: id (uuid PK), name, email (unique), emailVerified, image, role (roleEnum default "user"), avatarUrl, notifySlackEnabled (bool default false), slackUserId, notifyEmailEnabled (bool default false), notifyOnMention (bool default true), notifyOnActivity (bool default true), createdAt, updatedAt
       - `accounts`: composite PK on (provider, providerAccountId), userId FK to users with cascade delete, type, refresh_token, access_token, expires_at, token_type, scope, id_token, session_state
       - `sessions`: sessionToken (text PK), userId FK to users with cascade delete, expires
       - `verificationTokens`: composite PK on (identifier, token), expires

       **Application tables (14):**
       - `categories`: id, name, slug (unique), icon, sortOrder, parentCategoryId (self-ref FK), createdAt
       - `articles`: id, title, slug (unique), contentMarkdown, contentJson (jsonb, nullable -- for BlockNote Phase 5), technicalViewMarkdown, categoryId FK, parentArticleId (self-ref FK), sortOrder, lastAiGeneratedAt, lastHumanEditedAt, lastHumanEditorId FK to users, hasHumanEdits (bool), needsReview (bool default false), searchVector (tsvector generated always as `to_tsvector('english', coalesce(title, '') || ' ' || coalesce(content_markdown, ''))`), createdAt, updatedAt. Indexes: GIN on searchVector, btree on categoryId, btree on parentArticleId.
       - `articleVersions`: id, articleId FK, contentMarkdown, contentJson (jsonb, nullable), technicalViewMarkdown, changeSource (changeSourceEnum), changeSummary, createdBy FK to users (nullable -- null for AI), createdAt. Index on articleId.
       - `githubFiles`: id, filePath (unique), fileSha, contentHash, lastSyncedAt, createdAt, updatedAt
       - `excludedPaths`: id, pattern (unique), createdBy FK to users, createdAt
       - `articleFileLinks`: id, articleId FK, githubFileId FK, relevanceExplanation, createdAt. Unique on (articleId, githubFileId).
       - `articleDbTables`: id, articleId FK, tableName, columns (jsonb), relevanceExplanation, createdAt. Unique on (articleId, tableName).
       - `comments`: id, articleId FK, userId FK, parentCommentId (self-ref FK, nullable), contentMarkdown, isResolved (bool default false), resolvedBy FK to users (nullable), resolvedAt, createdAt, updatedAt. Index on articleId.
       - `mentions`: id, commentId FK, mentionedUserId FK, createdAt. Unique on (commentId, mentionedUserId).
       - `aiConversations`: id, userId FK, articleId FK (nullable -- null for global), mode (aiConversationModeEnum), title, createdAt, updatedAt. Index on userId, index on articleId.
       - `aiConversationMessages`: id, conversationId FK, role (aiMessageRoleEnum), content, createdAt. Index on conversationId.
       - `articleImages`: id, articleId FK (nullable), fileName, filePath, mimeType, sizeBytes, uploadedBy FK to users, createdAt. Index on articleId.
       - `siteSettings`: key (text PK), value (text default ""), description, isSecret (bool default false), updatedAt
       - `syncLogs`: id, status (syncStatusEnum), triggerType (triggerTypeEnum), startedAt, completedAt, filesProcessed (int default 0), articlesCreated (int default 0), articlesUpdated (int default 0), errorMessage, createdAt

       **CRITICAL:** Use `uuid("id").defaultRandom().primaryKey()` for all id columns. Use `timestamp("col_name", { withTimezone: true })` for all timestamps. Use `.notNull()` where the spec requires NOT NULL. Use `COALESCE` in the searchVector generated expression. Export ALL tables and enums.

       **CRITICAL:** For self-referencing foreign keys (categories.parentCategoryId, articles.parentArticleId, comments.parentCommentId), use `(): any =>` pattern to avoid circular reference TypeScript errors.

    4. Create `src/lib/db/migrate.ts` -- Migration runner using pg (TCP) driver:
       ```typescript
       import { drizzle } from "drizzle-orm/node-postgres";
       import { migrate } from "drizzle-orm/node-postgres/migrator";
       import { Pool } from "pg";

       const pool = new Pool({
         connectionString: process.env.DATABASE_URL_UNPOOLED!,
       });

       async function main() {
         const db = drizzle({ client: pool });
         console.log("Running migrations...");
         await migrate(db, { migrationsFolder: "./drizzle" });
         console.log("Migrations complete.");
         await pool.end();
       }

       main().catch((err) => {
         console.error("Migration failed:", err);
         process.exit(1);
       });
       ```

    5. Create `src/lib/db/seed.ts` -- Seed site_settings with all required keys:
       Use the exact seed script from research. Insert 12 required settings keys with `onConflictDoNothing`. Keys: github_repo_url, github_api_key, openrouter_api_key, openrouter_model (default "anthropic/claude-sonnet-4-20250514"), sync_cron_schedule (default "0 9 * * 6"), sendgrid_api_key, sendgrid_from_email, slack_bot_token, analysis_prompt, article_style_prompt, ask_ai_global_prompt, ask_ai_page_prompt. Mark API key fields with `isSecret: true`.

    6. Add npm scripts to package.json:
       ```json
       "db:generate": "drizzle-kit generate",
       "db:migrate": "tsx src/lib/db/migrate.ts",
       "db:seed": "tsx src/lib/db/seed.ts",
       "db:studio": "drizzle-kit studio"
       ```
       Install tsx as dev dependency: `npm install -D tsx`

    7. Generate the initial migration: `npm run db:generate`
       This should produce SQL files in `./drizzle/` directory with CREATE TABLE statements for all tables.

    8. Do NOT run db:migrate (requires real Neon connection). Just verify migration SQL was generated.
  </action>
  <verify>
    Run `npm run db:generate` -- must produce migration files in ./drizzle/ without errors.
    Run `npx tsc --noEmit` -- schema.ts must type-check without errors.
    Verify drizzle/ directory contains SQL with CREATE TABLE for: users, accounts, sessions, verification_tokens, categories, articles, article_versions, github_files, excluded_paths, article_file_links, article_db_tables, comments, mentions, ai_conversations, ai_conversation_messages, article_images, site_settings, sync_logs.
    Run `npm run build` -- must still pass with schema imports.
  </verify>
  <done>
    Complete Drizzle schema with 18 tables and 6 enums defined, migration SQL generated, db client (Neon HTTP) and migration runner (pg TCP) created, seed script ready, npm scripts configured. Schema is the single source of truth for all 7 phases.
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- `npm run db:generate` produces migration SQL for all tables
- `npx tsc --noEmit` passes type checking
- Dockerfile builds successfully (if Docker available)
- .env.example documents all required environment variables
- Schema exports all tables and enums needed by downstream plans
</verification>

<success_criteria>
1. The project builds with `npm run build` and produces standalone output
2. The Drizzle schema defines all 18 tables with correct column types, foreign keys, and indexes
3. Migration SQL files exist in ./drizzle/ with all CREATE TABLE statements
4. Docker infrastructure is in place (Dockerfile, docker-compose.yml, .dockerignore)
5. Dual database connection pattern is established (Neon HTTP for app, pg TCP for migrations)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-01-SUMMARY.md`
</output>
