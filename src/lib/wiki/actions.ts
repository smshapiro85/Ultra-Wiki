"use server";

import { auth } from "@/lib/auth";
import { getDb } from "@/lib/db";
import {
  articles,
  articleFileLinks,
  githubFiles,
  userBookmarks,
} from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import { getSetting } from "@/lib/settings";
import { SETTING_KEYS } from "@/lib/settings/constants";

// =============================================================================
// toggleBookmark
// =============================================================================

export async function toggleBookmark(
  articleId: string
): Promise<{ bookmarked: boolean }> {
  const session = await auth();

  if (!session?.user?.id) {
    throw new Error("Not authenticated");
  }

  const userId = session.user.id;
  const db = getDb();

  // Check if bookmark exists
  const existing = await db
    .select({ userId: userBookmarks.userId })
    .from(userBookmarks)
    .where(
      and(
        eq(userBookmarks.userId, userId),
        eq(userBookmarks.articleId, articleId)
      )
    )
    .limit(1);

  if (existing.length > 0) {
    // Remove bookmark
    await db
      .delete(userBookmarks)
      .where(
        and(
          eq(userBookmarks.userId, userId),
          eq(userBookmarks.articleId, articleId)
        )
      );
    revalidatePath("/");
    return { bookmarked: false };
  } else {
    // Add bookmark
    await db.insert(userBookmarks).values({
      userId,
      articleId,
    });
    revalidatePath("/");
    return { bookmarked: true };
  }
}

// =============================================================================
// regenerateArticle
// =============================================================================

/**
 * Admin-only server action to regenerate an article.
 *
 * Re-fetches linked source files from GitHub, re-runs AI generation
 * with the current style prompt, and updates the article.
 *
 * Merge strategy:
 * - AI-only articles: direct overwrite
 * - Human-edited articles: three-way merge with conflict resolution
 *
 * CRITICAL: All AI/merge modules are dynamically imported to avoid
 * @blocknote/server-util createContext crash in RSC module graph.
 */
export async function regenerateArticle(
  articleId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    // 1. Auth check
    const session = await auth();
    if (session?.user?.role !== "admin") {
      throw new Error("Unauthorized: admin access required");
    }

    const db = getDb();

    // 2. Load article
    const [article] = await db
      .select({
        id: articles.id,
        slug: articles.slug,
        title: articles.title,
        contentMarkdown: articles.contentMarkdown,
        hasHumanEdits: articles.hasHumanEdits,
        categoryId: articles.categoryId,
      })
      .from(articles)
      .where(eq(articles.id, articleId))
      .limit(1);

    if (!article) {
      throw new Error("Article not found");
    }

    // 3. Load linked file paths
    const linkedFiles = await db
      .select({
        filePath: githubFiles.filePath,
      })
      .from(articleFileLinks)
      .innerJoin(githubFiles, eq(articleFileLinks.githubFileId, githubFiles.id))
      .where(eq(articleFileLinks.articleId, articleId));

    const filePaths = linkedFiles.map((f) => f.filePath);

    if (filePaths.length === 0) {
      throw new Error(
        "No linked source files found. Cannot regenerate without source files."
      );
    }

    // 4. Fetch file contents from GitHub (dynamic import)
    const { fetchFileContents } = await import("@/lib/ai/analyze");
    const fileContents = await fetchFileContents(filePaths);

    if (fileContents.length === 0) {
      throw new Error(
        "Could not fetch any source file contents from GitHub."
      );
    }

    // 5. Get article style prompt
    const stylePrompt =
      (await getSetting(SETTING_KEYS.article_style_prompt)) ?? "";

    // 6. Generate new content (dynamic import)
    const { generateArticle } = await import("@/lib/ai/generate");
    const generated = await generateArticle(
      {
        slug: article.slug,
        title: article.title,
        action: "update" as const,
        content_markdown: "",
        technical_view_markdown: "",
        change_summary: "Regenerated by admin",
        related_files: filePaths,
        related_db_tables: [],
        category_suggestion: "",
      },
      stylePrompt
    );

    // 7. Apply content based on merge strategy
    const { createArticleVersion } = await import("@/lib/content/version");

    if (!article.hasHumanEdits) {
      // AI-only article: direct overwrite
      await db
        .update(articles)
        .set({
          contentMarkdown: generated.contentMarkdown,
          contentJson: null,
          technicalViewMarkdown: generated.technicalViewMarkdown,
          lastAiGeneratedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(articles.id, articleId));

      await createArticleVersion({
        articleId,
        contentMarkdown: generated.contentMarkdown,
        technicalViewMarkdown: generated.technicalViewMarkdown,
        changeSource: "ai_updated",
        changeSummary: "Regenerated by admin",
      });
    } else {
      // Human-edited article: three-way merge
      const { getLastAIVersion } = await import("@/lib/content/version");
      const { mergeArticleContent } = await import("@/lib/merge/three-way");
      const { resolveConflict } = await import("@/lib/merge/conflict");

      const lastAIVersion = await getLastAIVersion(articleId);
      const base = lastAIVersion?.contentMarkdown ?? "";

      const mergeResult = mergeArticleContent(
        base,
        article.contentMarkdown,
        generated.contentMarkdown
      );

      const resolution = await resolveConflict({
        articleId,
        mergeResult,
        currentMarkdown: article.contentMarkdown,
        aiProposedMarkdown: generated.contentMarkdown,
        changeSummary: "Regenerated by admin",
      });

      await db
        .update(articles)
        .set({
          contentMarkdown: resolution.finalMarkdown,
          contentJson: null,
          technicalViewMarkdown: generated.technicalViewMarkdown,
          lastAiGeneratedAt: new Date(),
          needsReview: resolution.needsReview,
          updatedAt: new Date(),
        })
        .where(eq(articles.id, articleId));

      // Only create version for clean merges (conflict path creates its own)
      if (!mergeResult.hasConflicts) {
        await createArticleVersion({
          articleId,
          contentMarkdown: resolution.finalMarkdown,
          technicalViewMarkdown: generated.technicalViewMarkdown,
          changeSource: resolution.changeSource,
          changeSummary: "Regenerated by admin",
        });
      }
    }

    // 8. Revalidate the article page
    revalidatePath(`/wiki/${article.slug}`, "page");

    return { success: true };
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Unknown error occurred";
    console.error("[regenerateArticle]", message);
    return { success: false, error: message };
  }
}
